Да, Артем, ты прав это несколько неправильный подход
Поправил как ты предложил, только немного в другом порядке

Изменил порядок соритровки
.withColumn('privious_city', lag('city', 1).over(Window.partitionBy("user_id").orderBy("group_id")))
прежний порядок менял местами текущий и предыдущий города
Отфильтровал совпадающие города
.where('city != privious_city or privious_city is null')
Определил дату проживания в прежнем городе
.withColumn('privious_date', lag('date', 1).over(Window.partitionBy('user_id').orderBy('group_id')))\
если дата проживания в прежнем городе существовала то считаем разницу между текущей датой и датой проживания в прежнем городе
если нет, считаем разницу между current_date и сообщением
.withColumn('lived_here_days', expr("case when privious_date is not null then datediff(date, privious_date)\
                                      else datediff(current_date(), date) end"))\
фильтруем разницу
.where('lived_here_days>26')\
оставляем только одну последнюю по дате запись по каждому пользователю
.withColumn('rank_days', row_number().over(Window.partitionBy("user_id").orderBy(desc("date")))) \
.where('rank_days=1').select('user_id', col('city').alias('home_city'))

Вроде все как было задумано) если нет, будем править)